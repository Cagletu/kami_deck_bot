–¥–∞–Ω–Ω—ã–µ –≤ –±–¥ –Ω–∞–∫–æ–Ω–µ—Ü —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –ø–æ—Å–ª–µ –∞—Ä–µ–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
–¥–∞–≤–∞–π –ø—Ä–∏–¥—É–º–∞–µ–º —á—Ç–æ –µ—â–µ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å/—É–ª—É—á—à–∏—Ç—å –≤ –Ω–∞—à–µ–º –±–æ—Ç–µ, –ø—Ä–µ–¥–ª–∞–≥–∞—é —Å–¥–µ–ª–∞—Ç—å –Ω–µ–æ–±—ã—á–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–∞–∫–∞ —Å –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏ –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å api –≤–∏–∫—Ç–æ—Ä–∏–Ω—É –ø–æ –∞–Ω–∏–º–µ —Å –Ω–∞–≥—Ä–∞–¥–∞–º–∏ –≤ –±–æ—Ç–µ, —á—Ç–æ –¥—É–º–∞–µ—à—å? 

arena.py:



from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from sqlalchemy import select, and_, func
import json
import random
import uuid
from datetime import datetime
import logging

from database.base import AsyncSessionLocal
from database.crud import get_user_or_create
from database.models.user import User
from database.models.user_card import UserCard
from database.models.card import Card
from database.models.arena_battle import ArenaBattle as DBArenaBattle
from game.arena_battle_system import ArenaBattle, BattleCard
from services.redis_client import battle_storage


router = Router()
logger = logging.getLogger(__name__)

# URL –¥–ª—è WebApp (–≤–∞—à Railway –¥–æ–º–µ–Ω)
WEBAPP_URL = "https://kamideckbot-production.up.railway.app/arena.html"


def generate_init_data(user_id: int, battle_id: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–º–∏—Ç–∞—Ü–∏—é init_data –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ URL
    """
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö
    data = {
        "user_id": str(user_id),
        "battle_id": battle_id,
        "timestamp": str(int(datetime.now().timestamp()))
    }

    # –ö–æ–¥–∏—Ä—É–µ–º –≤ JSON –∏ –∑–∞—Ç–µ–º –≤ base64 –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –ø–µ—Ä–µ–¥–∞—á–∏ –≤ URL
    import base64
    json_str = json.dumps(data)
    encoded = base64.b64encode(json_str.encode()).decode()

    return encoded


async def get_user_deck(user_id: int) -> list:
    """–ü–æ–ª—É—á–∞–µ—Ç –∫–æ–ª–æ–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–æ 5 –∫–∞—Ä—Ç)"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(
            select(UserCard, Card)
            .join(Card, UserCard.card_id == Card.id)
            .where(and_(UserCard.user_id == user_id, UserCard.is_in_deck == True))
            .order_by(Card.rarity.desc())
            .limit(5)
        )
        return result.all()


async def generate_opponent(user_id: int) -> tuple:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–ª–æ–¥—É –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞"""

    async with AsyncSessionLocal() as session:

        # –ò—â–µ–º –∏–≥—Ä–æ–∫–æ–≤ —Å –ø–æ–ª–Ω–æ–π –∫–æ–ª–æ–¥–æ–π (>=5 –∫–∞—Ä—Ç)
        result = await session.execute(
            select(User)
            .where(
                User.id != user_id,
                func.coalesce(func.json_array_length(User.selected_deck), 0) >= 5,
            )
            .order_by(func.random())
            .limit(1)
        )

        opponent = result.scalar_one_or_none()

        if opponent and opponent.selected_deck:

            result = await session.execute(
                select(UserCard, Card)
                .join(Card, UserCard.card_id == Card.id)
                .where(UserCard.id.in_(opponent.selected_deck))
                .limit(5)
            )

            opponent_cards = result.all()

            if len(opponent_cards) >= 5:
                logger.info(f"Found real opponent: {opponent.id}")
                return opponent_cards, opponent.id

        logger.info("No real opponent found, generating test deck")
        return await generate_test_deck(), None


async def generate_test_deck() -> list:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é –∫–æ–ª–æ–¥—É"""
    async with AsyncSessionLocal() as session:
        result = await session.execute(select(Card).order_by(func.random()).limit(5))
        cards = result.scalars().all()

        test_deck = []
        for i, card in enumerate(cards):
            level = random.randint(5, 20)

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —É—Ä–æ–≤–Ω—è
            power = int(card.base_power * (1 + (level - 1) * 0.06))  # +6% –∑–∞ —É—Ä–æ–≤–µ–Ω—å
            health = int(card.base_health * (1 + (level - 1) * 0.04))  # +4% –∑–∞ —É—Ä–æ–≤–µ–Ω—å
            attack = int(card.base_attack * (1 + (level - 1) * 0.07))  # +7% –∑–∞ —É—Ä–æ–≤–µ–Ω—å
            defense = int(
                card.base_defense * (1 + (level - 1) * 0.04)
            )  # +4% –∑–∞ —É—Ä–æ–≤–µ–Ω—å

            # –î–æ–±–∞–≤–ª—è–µ–º –±–æ–Ω—É—Å —Ä–µ–¥–∫–æ—Å—Ç–∏
            rarity_mult = {
                "E": 1.0,
                "D": 1.1,
                "C": 1.2,
                "B": 1.3,
                "A": 1.45,
                "S": 1.65,
                "ASS": 1.8,
                "SSS": 2.0,
            }.get(card.rarity, 1.0)

            power = int(power * rarity_mult)
            health = int(health * rarity_mult)
            attack = int(attack * rarity_mult)
            defense = int(defense * rarity_mult)

            test_deck.append(
                (
                    type(
                        "UserCard",
                        (),
                        {
                            "id": -i - 1,
                            "user_id": -1,
                            "card_id": card.id,
                            "level": level,
                            "current_power": power,
                            "current_health": health,
                            "current_attack": attack,
                            "current_defense": defense,
                            "is_in_deck": True,
                        },
                    ),
                    card,
                )
            )

        return test_deck


def prepare_battle_cards(cards_data: list, is_user: bool = True) -> list:
    """–ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç –∫–∞—Ä—Ç—ã –¥–ª—è –±–æ—è"""
    battle_cards = []
    for i, (user_card, card) in enumerate(cards_data[:5]):
        battle_card = BattleCard(
            id=user_card.id if is_user else -user_card.id,
            user_card_id=user_card.id,
            name=card.card_name,
            rarity=card.rarity,
            anime=card.anime_name or "Unknown",
            power=user_card.current_power,
            health=user_card.current_health,
            max_health=user_card.current_health,
            attack=user_card.current_attack,
            defense=user_card.current_defense,
            level=user_card.level,
            image_url=card.original_url,
            position=i,
        )
        battle_cards.append(battle_card)
    return battle_cards


@router.message(Command("arena"))
async def cmd_arena(message: types.Message, user_id: int = None):
    """–í—Ö–æ–¥ –Ω–∞ –∞—Ä–µ–Ω—É"""
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–æ–π ID –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
    if user_id:
        tg_id = user_id
    else:
        tg_id = message.from_user.id

    try:
        async with AsyncSessionLocal() as session:
            user = await get_user_or_create(session, tg_id)

        logger.info(f"Arena user: tg_id={tg_id}, db_id={user.id}")

        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–æ–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_deck = await get_user_deck(user.id)

        if len(user_deck) < 5:
            await message.answer(
                "‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ!</b>\n\n"
                f"–°–µ–π—á–∞—Å –≤ –∫–æ–ª–æ–¥–µ: {len(user_deck)}/5 –∫–∞—Ä—Ç\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /collection —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Ä—Ç—ã –≤ –∫–æ–ª–æ–¥—É",
                reply_markup=InlineKeyboardMarkup(
                    inline_keyboard=[
                        [
                            InlineKeyboardButton(
                                text="üÉè –ö –∫–æ–ª–ª–µ–∫—Ü–∏–∏",
                                callback_data="collection_by_rarity",
                            )
                        ]
                    ]
                ),
            )
            return

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        opponent_deck, opponent_id = await generate_opponent(user.id)

        # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –±–æ—è
        battle_id = str(uuid.uuid4())

        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫–∞—Ä—Ç—ã
        user_battle_cards = prepare_battle_cards(user_deck, is_user=True)
        opponent_battle_cards = prepare_battle_cards(opponent_deck, is_user=False)

        # –°–æ–∑–¥–∞–µ–º –±–æ–π
        battle = ArenaBattle(user_battle_cards, opponent_battle_cards)

        battle_data = {
            "user_id": message.from_user.id,
            "opponent_id": opponent_id,
            "player_cards": [card.to_dict() for card in user_battle_cards],
            "enemy_cards": [card.to_dict() for card in opponent_battle_cards],
            "turn": 0,
            "winner": None,
            "created_at": datetime.now().isoformat(),
        }

        logger.info(
            f"Saving battle {battle_id} to Redis: {len(battle_data['player_cards'])} player cards, {len(battle_data['enemy_cards'])} enemy cards"
        )
        await battle_storage.save_battle(battle_id, battle_data)

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º init_data –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ URL
        init_data = generate_init_data(tg_id, battle_id)

        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É —Å WebApp –∏ –ø–µ—Ä–µ–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ URL
        webapp_url = f"{WEBAPP_URL}?battle_id={battle_id}&init_data={init_data}"

        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º InlineKeyboardMarkup —Å web_app
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="‚öîÔ∏è –ù–ê–ß–ê–¢–¨ –ë–ò–¢–í–£",
                        web_app=WebAppInfo(url=webapp_url),
                    )
                ],
                [InlineKeyboardButton(text="¬´ –ù–∞–∑–∞–¥", callback_data="back_to_main")],
            ]
        )


        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–∏—Ç–≤–µ
        text = f"""
<b>‚öîÔ∏è –ê–†–ï–ù–ê –ñ–î–ï–¢!</b>

üìä <b>–í–∞—à–∞ –∫–æ–ª–æ–¥–∞:</b> 5/5 –∫–∞—Ä—Ç
{'‚≠ê –ï—Å—Ç—å —Å–∏–Ω–µ—Ä–≥–∏—è!' if battle.player_synergies else 'üîÑ –ë–µ–∑ —Å–∏–Ω–µ—Ä–≥–∏–∏'}

üëπ <b>–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫:</b> {'–†–µ–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫' if opponent_id else '–¢–µ—Å—Ç–æ–≤–∞—è –∫–æ–ª–æ–¥–∞'}

‚ö° <b>–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –±–∏—Ç–≤—É!</b>

<i>‚ö†Ô∏è –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –±–æ—è –Ω–∞–∂–º–∏—Ç–µ "–ó–ê–ö–†–´–¢–¨" –≤ –∞—Ä–µ–Ω–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–∞–≥—Ä–∞–¥</i>
"""

        await message.answer(text, reply_markup=keyboard)

    except Exception as e:
        logger.exception(f"–û—à–∏–±–∫–∞ cmd_arena: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")


@router.callback_query(F.data == "open_arena")
async def open_arena(callback: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è –∞—Ä–µ–Ω—ã"""
    try:
        # –ü–µ—Ä–µ–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
        await cmd_arena(callback.message, callback.from_user.id)
        await callback.answer()
    except Exception as e:
        logger.exception(f"–û—à–∏–±–∫–∞ –≤ open_arena: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –∞—Ä–µ–Ω—ã", show_alert=True)


@router.message(F.web_app_data)
async def handle_webapp_data(message: types.Message):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ WebApp"""
    try:
        # üö® –í–ê–ñ–ù–û: –ª–æ–≥–∏—Ä—É–µ–º –í–°–ï –≤—Ö–æ–¥—è—â–∏–µ –¥–∞–Ω–Ω—ã–µ
        logger.info("=" * 50)
        logger.info("üî• –ü–û–õ–£–ß–ï–ù–´ WEBAPP DATA!")
        logger.info(f"User ID: {message.from_user.id}")
        logger.info(f"Raw data: {message.web_app_data.data}")

        data = json.loads(message.web_app_data.data)
        logger.info(f"Parsed data: {data}")

        action = data.get("action")
        battle_id = data.get("battle_id")
        result = data.get("result")
        rewards = data.get("rewards", {})

        logger.info(f"Action: {action}")
        logger.info(f"Battle ID: {battle_id}")
        logger.info(f"Result: {result}")
        logger.info(f"Rewards: {rewards}")

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±–∏—Ç–≤—ã
        if action == "battle_result":
            logger.info(f"üéØ Processing battle result: {result}")

            async with AsyncSessionLocal() as session:
                user = await get_user_or_create(session, message.from_user.id)

                # –ù–∞—á–∏—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—ã
                if result == "win":
                    rating_change = rewards.get("rating", 20)
                    coins_reward = rewards.get("coins", 50)
                    dust_reward = rewards.get("dust", 50)

                    user.arena_wins += 1
                    user.arena_rating += rating_change
                    user.coins += coins_reward
                    user.dust += dust_reward

                elif result == "lose":
                    rating_change = rewards.get("rating", -15)
                    coins_reward = rewards.get("coins", 25)
                    dust_reward = rewards.get("dust", 25)

                    user.arena_losses += 1
                    user.arena_rating = max(0, user.arena_rating + rating_change)
                    user.coins += coins_reward
                    user.dust += dust_reward

                await session.commit()

                logger.info(f"‚úÖ User updated: wins={user.arena_wins}, rating={user.arena_rating}")

                # –£–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –∞—Ä–µ–Ω—ã
                from aiogram.types import ReplyKeyboardRemove

                await message.answer(
                    f"{'üéâ' if result == 'win' else 'üòî'} <b>–ë–ò–¢–í–ê –ó–ê–í–ï–†–®–ï–ù–ê!</b>\n\n"
                    f"üí∞ –ü–æ–ª—É—á–µ–Ω–æ: +{coins_reward}üí∞ +{dust_reward}‚ú®\n"
                    f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {user.arena_rating}",
                    reply_markup=ReplyKeyboardRemove()
                )

                # –£–¥–∞–ª—è–µ–º –±–∏—Ç–≤—É –∏–∑ Redis
                if battle_id:
                    await battle_storage.delete_battle(battle_id)

    except Exception as e:
        logger.exception(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ WebApp –¥–∞–Ω–Ω—ã—Ö: {e}")
        await message.answer(json.dumps({"type": "error", "message": str(e)}))















arena.html:




<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kami Deck - –ê—Ä–µ–Ω–∞</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .arena-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .turn-counter {
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
        }

        .sections {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .section {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .section h3 {
            margin: 0 0 15px 0;
            text-align: center;
            color: #4ecdc4;
        }

        .card-slot {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            transition: all 0.3s;
        }

        .card-slot:hover {
            border-color: #4ecdc4;
            transform: translateY(-2px);
        }

        .card-slot.selected {
            border-color: #ff6b6b;
            background: rgba(255,107,107,0.1);
        }

        .card-name {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 9px;
            color: rgba(255,255,255,0.7);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .button.auto {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .button.close {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .button:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .battle-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 14px;
        }

        .enemy-card {
            text-align: center;
            padding: 10px;
            background: rgba(255,107,107,0.1);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #4ecdc4;
        }

        .error-message {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
        }

        .health-bar {
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            margin-top: 5px;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            border-radius: 3px;
            transition: width 0.3s;
        }

        .enemy-health-bar {
            background: rgba(255,107,107,0.2);
        }

        .enemy-health-bar-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
        }

        .card-image {
            width: 100%;
            height: 70px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 8px;
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.3s;
        }

        .card-slot:hover .card-image {
            border-color: #4ecdc4;
            transform: scale(1.02);
        }

        .enemy-card .card-image {
            height: 60px;
        }

        @keyframes slash {
            0% { transform: scale(1); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        .slash-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            pointer-events: none;
            animation: slash 0.3s ease-out;
            z-index: 1000;
        }

        .crit-effect {
            background: radial-gradient(circle, rgba(255,215,0,0.9) 0%, rgba(255,215,0,0) 70%);
        }
    </style>
</head>
<body>
    <div class="arena-container">
        <div class="header">
            <div class="title">‚öîÔ∏è –ê–†–ï–ù–ê ‚öîÔ∏è</div>
            <div class="turn-counter">–•–æ–¥: <span id="turn">0</span></div>
        </div>

        <div id="loading" class="loading">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –±–∏—Ç–≤—ã...</div>

        <div class="sections" id="battle-sections" style="display: none;">
            <div class="section">
                <h3>‚öîÔ∏è –í–ê–®–ê –ö–û–õ–û–î–ê</h3>
                <div id="player-cards"></div>
            </div>

            <div class="section">
                <h3>üëπ –ü–†–û–¢–ò–í–ù–ò–ö</h3>
                <div id="enemy-cards"></div>
            </div>
        </div>

        <div class="battle-log" id="battle-log" style="display: none;"></div>

        <div class="controls" id="battle-controls" style="display: none;">
            <button class="button auto" onclick="nextTurn()" id="nextTurnBtn">‚ö° –°–õ–ï–î–£–Æ–©–ò–ô –•–û–î</button>
            <button class="button auto" onclick="autoBattle()" id="autoBattleBtn" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">ü§ñ –ê–í–¢–û–ë–û–ô</button>
            <button class="button close" onclick="closeArena()">üè† –ó–ê–ö–†–´–¢–¨</button>
        </div>

        <div id="error" class="error-message" style="display: none;"></div>
    </div>

    <script>
        let tg = null;
        let battleId = null;
        let playerCards = {};
        let enemyCards = {};
        let currentTurn = 0;
        let battleLog = [];

        console.log('Current URL:', window.location.href);
        console.log('Search params:', window.location.search);

        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Ç–∫—Ä—ã—Ç–æ –ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤ Telegram
            if (window.Telegram && window.Telegram.WebApp) {
                tg = window.Telegram.WebApp;
                tg.expand();
                tg.ready();

                console.log('Telegram WebApp –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
                console.log('Init data:', tg.initData); // üëà –ü–û–õ–£–ß–ê–ï–ú INIT DATA

                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–∫—Ä—ã—Ç–∏—è
                window.addEventListener('beforeunload', function() {
                    console.log('WebApp –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è');
                });
            } else {
                console.log('–†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏: –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ –≤ –±—Ä–∞—É–∑–µ—Ä–µ');
            }
        } catch (e) {
            console.log('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Telegram WebApp:', e);
        }

        // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ URL
        function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            return {
                battle_id: urlParams.get('battle_id'),
                init_data: urlParams.get('init_data')
            };
        }

        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º init_data
        function decodeInitData(encoded) {
            try {
                if (!encoded) return null;
                const jsonStr = atob(encoded);
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Failed to decode init_data:', e);
                return null;
            }
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        const urlParams = getUrlParams();
        battleId = urlParams.battle_id;
        const initData = decodeInitData(urlParams.init_data);

        console.log('Battle ID:', battleId);
        console.log('Init data:', initData);

        if (initData && initData.user_id) {
            console.log('User ID from init_data:', initData.user_id);
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º user_id –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            window.userId = initData.user_id;
        }

        // –ü–æ–ª—É—á–∞–µ–º battle_id –∏–∑ URL
        function getBattleIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const id = urlParams.get('battle_id');
            console.log('Extracted battle_id:', id);
            return id;
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –±–∏—Ç–≤—ã
        async function loadBattle() {
            battleId = getBattleIdFromUrl();

            console.log('URL params:', window.location.search);
            console.log('Battle ID from URL:', battleId);

            if (!battleId) {
                showError('ID –±–∏—Ç–≤—ã –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ URL');
                return;
            }

            console.log('–ó–∞–≥—Ä—É–∑–∫–∞ –±–∏—Ç–≤—ã:', battleId);

            try {
                const response = await fetch(`/api/battle/${battleId}`);
                const data = await response.json();

                console.log('–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ:', data);

                // –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–∞—Ä—Ç –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                if (data.success && data.player_cards && data.player_cards.length > 0) {
                    console.log('–ü—Ä–∏–º–µ—Ä –∫–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞:', data.player_cards[0]);
                    console.log('–ü–æ–ª–µ is_alive:', data.player_cards[0].is_alive);
                    console.log('–ó–¥–æ—Ä–æ–≤—å–µ:', data.player_cards[0].health);
                }

                if (data.success) {
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–∞—Å—Å–∏–≤—ã –∫–∞—Ä—Ç –≤ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
                    data.player_cards.forEach(card => {
                        playerCards[card.id] = card;
                    });
                    data.enemy_cards.forEach(card => {
                        enemyCards[card.id] = card;
                    });

                    currentTurn = data.turn || 0;

                    // –ü—Ä—è—á–µ–º –∑–∞–≥—Ä—É–∑–∫—É, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('battle-sections').style.display = 'flex';
                    document.getElementById('battle-log').style.display = 'block';
                    document.getElementById('battle-controls').style.display = 'flex';

                    renderBattle();

                    addLog('‚öîÔ∏è –ë–∏—Ç–≤–∞ –Ω–∞—á–∞–ª–∞—Å—å!');
                } else {
                    showError(data.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –±–∏—Ç–≤—É');
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', error);
                showError('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É');
            }
        }

        function renderBattle() {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ —Ö–æ–¥–∞
            document.getElementById('turn').textContent = currentTurn;

            // –†–µ–Ω–¥–µ—Ä–∏–º –∫–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞
            renderPlayerCards();

            // –†–µ–Ω–¥–µ—Ä–∏–º –∫–∞—Ä—Ç—ã –≤—Ä–∞–≥–∞
            renderEnemyCards();
        }

        function renderPlayerCards() {
            const container = document.getElementById('player-cards');
            container.innerHTML = '';

            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–∞—Ä—Ç—ã –ø–æ –ø–æ–∑–∏—Ü–∏–∏
            const sortedCards = Object.values(playerCards).sort((a, b) => a.position - b.position);

            sortedCards.forEach(card => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∂–∏–≤–∞ –ª–∏ –∫–∞—Ä—Ç–∞ (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –æ–±–æ–∏—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤)
                const isAlive = card.is_alive !== undefined ? card.is_alive : card.health > 0;
                if (!isAlive) return;

                const healthPercent = (card.health / card.max_health) * 100;

                const cardEl = document.createElement('div');
                cardEl.setAttribute('data-card-id', card.id);
                cardEl.className = 'card-slot';
                cardEl.onclick = () => selectCard(card.id);
                cardEl.innerHTML = `
                <div style="position: relative;">
                    ${card.image_url ? `<img src="${card.image_url}" style="width: 100%; height: 70px; object-fit: cover; border-radius: 5px; margin-bottom: 5px;">` : ''}
                </div>
                <div class="card-name">${card.name}</div>
                <div class="card-stats">
                    <span>üí™ ${card.power}</span>
                    <span>‚ù§Ô∏è ${card.health}/${card.max_health}</span>
                    <span>‚öîÔ∏è ${card.attack}</span>
                    <span>üõ°Ô∏è ${card.defense}</span>
                </div>
                    <div class="health-bar">
                        <div class="health-bar-fill" style="width: ${healthPercent}%"></div>
                    </div>
                `;
                container.appendChild(cardEl);
            });
        }

        function renderEnemyCards() {
            const container = document.getElementById('enemy-cards');
            container.innerHTML = '';

            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–∞—Ä—Ç—ã –ø–æ –ø–æ–∑–∏—Ü–∏–∏
            const sortedCards = Object.values(enemyCards).sort((a, b) => a.position - b.position);

            sortedCards.forEach(card => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∂–∏–≤–∞ –ª–∏ –∫–∞—Ä—Ç–∞ (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –æ–±–æ–∏—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤)
                const isAlive = card.is_alive !== undefined ? card.is_alive : card.health > 0;
                if (!isAlive) return;

                const healthPercent = (card.health / card.max_health) * 100;

                const cardEl = document.createElement('div');
                cardEl.setAttribute('data-card-id', card.id);
                cardEl.className = 'enemy-card';
                cardEl.innerHTML = `
                    <div style="position: relative;">
                        ${card.image_url ? `<img src="${card.image_url}" style="width: 100%; height: 70px; object-fit: cover; border-radius: 5px; margin-bottom: 5px;">` : ''}
                    </div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-stats">
                    <span>üí™ ${card.power}</span>
                    <span>‚ù§Ô∏è ${card.health}/${card.max_health}</span>
                    <span>‚öîÔ∏è ${card.attack}</span>
                    <span>üõ°Ô∏è ${card.defense}</span>
                    </div>
                    <div class="health-bar enemy-health-bar">
                        <div class="health-bar-fill enemy-health-bar-fill" style="width: ${healthPercent}%"></div>
                    </div>
                `;
                container.appendChild(cardEl);
            });
        }

        function addLog(message) {
            battleLog.push(message);
            const logContainer = document.getElementById('battle-log');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = message;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function selectCard(cardId) {
            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ä—Ç—ã
            document.querySelectorAll('.card-slot').forEach(el => {
                if (el.getAttribute('data-card-id') == cardId) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });

            // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏
        }

        // –í arena.html, –æ–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏ nextTurn –∏ autoBattle

        async function nextTurn() {
            const btn = document.getElementById('nextTurnBtn');
            btn.disabled = true;
            btn.textContent = '‚ö° –ë–û–ô –ò–î–ï–¢...';

            let data = null;

            try {
                const response = await fetch('/api/battle/turn', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ battle_id: battleId })
                });

                data = await response.json();

                if (!data.success) {
                    addLog('‚ùå ' + (data.error || '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'));
                    return;
                }

                // 1Ô∏è‚É£ –ê–Ω–∏–º–∞—Ü–∏–∏
                if (data.actions?.length) {
                    for (const action of data.actions) {
                        await animateAttack(
                            action.attacker_id,
                            action.defender_id,
                            action.damage,
                            action.is_critical,
                            action.attacker_id > 0
                        );
                        await new Promise(r => setTimeout(r, 150));
                    }
                }

                // 2Ô∏è‚É£ –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞—Ä—Ç—ã
                updateCards(data);

                // 3Ô∏è‚É£ –õ–æ–≥–∏
                if (data.log) {
                    data.log.forEach(log => addLog(log));
                }

                renderBattle();

                // 4Ô∏è‚É£ –ï—Å–ª–∏ –±–æ–π –∑–∞–≤–µ—Ä—à—ë–Ω
                if (data.winner) {
                    await endBattle(data.winner, data.rewards);
                }

            } catch (e) {
                console.error(e);
                addLog('‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
            } finally {
                if (!data?.winner) {
                    btn.disabled = false;
                    btn.textContent = '‚ö° –°–õ–ï–î–£–Æ–©–ò–ô –•–û–î';
                }
            }
        }


        async function autoBattle() {
            const autoBtn = document.getElementById('autoBattleBtn');
            const turnBtn = document.getElementById('nextTurnBtn');

            autoBtn.disabled = true;
            turnBtn.disabled = true;

            try {
                while (true) {

                    const alivePlayers = getAliveCards(playerCards);
                    const aliveEnemies = getAliveCards(enemyCards);

                    if (alivePlayers.length === 0 || aliveEnemies.length === 0) {
                        break;
                    }

                    const response = await fetch('/api/battle/turn', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ battle_id: battleId })
                    });

                    const data = await response.json();

                    if (!data.success) break;

                    // –ê–Ω–∏–º–∞—Ü–∏–∏
                    if (data.actions?.length) {
                        for (const action of data.actions) {
                            await animateAttack(
                                action.attacker_id,
                                action.defender_id,
                                action.damage,
                                action.is_critical,
                                action.attacker_id > 0
                            );
                            await new Promise(r => setTimeout(r, 120));
                        }
                    }

                    updateCards(data);

                    if (data.log) {
                        for (const log of data.log) {
                            addLog(log);
                            await new Promise(r => setTimeout(r, 120));
                        }
                    }

                    renderBattle();

                    if (data.winner) {
                        await endBattle(data.winner, data.rewards);
                        break;
                    }

                    await new Promise(r => setTimeout(r, 400));
                }

            } catch (e) {
                console.error(e);
                addLog('‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
            }

            autoBtn.disabled = false;
            turnBtn.disabled = false;
        }

        function closeArena() {
            console.log('Closing arena...');

            // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –∑–∞–∫—Ä—ã—Ç–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
            if (tg) {
                try {
                    // –î–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                    tg.close();
                } catch (e) {
                    console.error('Error closing via tg:', e);
                    // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–ø–æ—Å–æ–± –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
                    window.location.href = 'https://t.me/KamiDeckBot';
                }
            } else {
                // –ï—Å–ª–∏ –Ω–µ –≤ Telegram, –ø—Ä–æ—Å—Ç–æ —Ä–µ–¥–∏—Ä–µ–∫—Ç
                window.location.href = 'https://t.me/KamiDeckBot';
            }
        }


        async function endBattle(winner, rewards) {
            // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫–∏
            const nextBtn = document.getElementById('nextTurnBtn');
            const autoBtn = document.getElementById('autoBattleBtn');
            const closeBtn = document.querySelector('.button.close');

            if (nextBtn) nextBtn.disabled = true;
            if (autoBtn) autoBtn.disabled = true;

            if (winner === 'player') {
                addLog('üéâ –ü–û–ë–ï–î–ê!');
                if (rewards) {
                    addLog(`üí∞ –ù–∞–≥—Ä–∞–¥—ã: +${rewards.coins}üí∞ +${rewards.dust}‚ú® +${rewards.rating}‚≠ê`);
                }

                // üëá –û–¢–ü–†–ê–í–õ–Ø–ï–ú –†–ï–ó–£–õ–¨–¢–ê–¢ –ß–ï–†–ï–ó API –° initData
                try {
                    // –ü–æ–ª—É—á–∞–µ–º initData –∏–∑ URL (–º—ã –ø–µ—Ä–µ–¥–∞–ª–∏ –µ—ë –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏)
                    const urlParams = new URLSearchParams(window.location.search);
                    const initData = urlParams.get('init_data');

                    const response = await fetch('/api/battle/result', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Init-Data': initData || '' // üëà –ü–µ—Ä–µ–¥–∞–µ–º initData –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ
                        },
                        body: JSON.stringify({
                            action: 'battle_result',
                            battle_id: battleId,
                            result: 'win',
                            rewards: rewards
                        })
                    });

                    const data = await response.json();
                    console.log('Battle result sent:', data);

                } catch (error) {
                    console.error('Failed to send battle result:', error);
                }

            } else if (winner === 'enemy') {
                addLog('üòî –ü–æ—Ä–∞–∂–µ–Ω–∏–µ...');
                if (rewards) {
                    addLog(`üí∞ –ù–∞–≥—Ä–∞–¥—ã: +${rewards.coins}üí∞ +${rewards.dust}‚ú® ${rewards.rating}‚≠ê`);
                }

                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const initData = urlParams.get('init_data');

                    const response = await fetch('/api/battle/result', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Init-Data': initData || ''
                        },
                        body: JSON.stringify({
                            action: 'battle_result',
                            battle_id: battleId,
                            result: 'lose',
                            rewards: rewards
                        })
                    });

                } catch (error) {
                    console.error('Failed to send battle result:', error);
                }
            }

            // –ó–∞–∫—Ä—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
            setTimeout(() => {
                if (tg) tg.close();
            }, 3000);
        }


        async function animateAttack(attackerId, defenderId, damage, isCritical, isPlayerAttacker = true) {
            const attackerEl = document.querySelector(`[data-card-id="${attackerId}"]`);
            const defenderEl = document.querySelector(`[data-card-id="${defenderId}"]`);

            if (!attackerEl || !defenderEl) {
                console.log('Animation skipped: element not found', {attackerId, defenderId});
                return;
            }

            try {
                const attackColor = isPlayerAttacker ? '#4ecdc4' : '#ff6b6b';

                // –ê–Ω–∏–º–∞—Ü–∏—è –∞—Ç–∞–∫—É—é—â–µ–≥–æ
                attackerEl.style.transform = 'scale(1.1)';
                attackerEl.style.boxShadow = `0 0 15px ${attackColor}`;
                attackerEl.style.transition = 'all 0.1s';
                await new Promise(resolve => setTimeout(resolve, 100));
                attackerEl.style.transform = 'scale(1)';
                attackerEl.style.boxShadow = 'none';

                // –≠—Ñ—Ñ–µ–∫—Ç —É–¥–∞—Ä–∞
                const rect = defenderEl.getBoundingClientRect();
                const slash = document.createElement('div');
                slash.className = 'slash-effect' + (isCritical ? ' crit-effect' : '');
                slash.style.position = 'fixed';
                slash.style.left = (rect.left + rect.width/2 - 50) + 'px';
                slash.style.top = (rect.top + rect.height/2 - 50) + 'px';
                slash.style.width = '100px';
                slash.style.height = '100px';
                slash.style.borderRadius = '50%';
                slash.style.background = isCritical ? 
                    'radial-gradient(circle, rgba(255,215,0,0.9) 0%, rgba(255,215,0,0) 70%)' : 
                    'radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)';
                slash.style.animation = 'slash 0.3s ease-out';
                slash.style.pointerEvents = 'none';
                slash.style.zIndex = '1000';
                document.body.appendChild(slash);

                setTimeout(() => slash.remove(), 300);

                // –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞—â–∏—â–∞—é—â–µ–≥–æ—Å—è
                defenderEl.style.backgroundColor = isCritical ? attackColor : 'rgba(255,255,255,0.2)';
                defenderEl.style.transform = 'translateX(5px)';
                await new Promise(resolve => setTimeout(resolve, 100));
                defenderEl.style.backgroundColor = '';
                defenderEl.style.transform = 'translateX(0)';

                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É—Ä–æ–Ω
                const damageEl = document.createElement('div');
                damageEl.style.position = 'fixed';
                damageEl.style.color = isCritical ? '#ffd700' : '#ffffff';
                damageEl.style.fontSize = isCritical ? '28px' : '24px';
                damageEl.style.fontWeight = 'bold';
                damageEl.style.zIndex = '1001';
                damageEl.style.textShadow = '2px 2px 4px black';
                damageEl.style.pointerEvents = 'none';
                damageEl.innerHTML = isCritical ? `‚ö°${damage}‚ö°` : `-${damage}`;

                const defenderRect = defenderEl.getBoundingClientRect();
                damageEl.style.left = (defenderRect.left + defenderRect.width/2 - 20) + 'px';
                damageEl.style.top = defenderRect.top + 'px';

                document.body.appendChild(damageEl);

                // –ê–Ω–∏–º–∞—Ü–∏—è —É—Ä–æ–Ω–∞
                for (let i = 0; i < 10; i++) {
                    damageEl.style.opacity = (10 - i) / 10;
                    damageEl.style.top = (defenderRect.top - i*3) + 'px';
                    await new Promise(resolve => setTimeout(resolve, 20));
                }
                damageEl.remove();

            } catch (error) {
                console.error('Animation error:', error);
                // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –ø–æ—Ç–æ–∫ –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å
            }
        }


        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞–≥—Ä–∞–¥
        function showRewards(rewards) {
            if (!rewards) return;

            const logContainer = document.getElementById('battle-log');
            const rewardsEl = document.createElement('div');
            rewardsEl.className = 'log-entry';
            rewardsEl.style.background = 'linear-gradient(135deg, #f1c40f, #f39c12)';
            rewardsEl.style.color = 'black';
            rewardsEl.style.fontWeight = 'bold';
            rewardsEl.style.marginTop = '10px';
            rewardsEl.style.padding = '10px';
            rewardsEl.style.borderRadius = '5px';
            rewardsEl.innerHTML = `
                üéÅ –ù–ê–ì–†–ê–î–´:<br>
                üí∞ ${rewards.coins} –º–æ–Ω–µ—Ç<br>
                ‚ú® ${rewards.dust} –ø—ã–ª–∏<br>
                üìà ${rewards.rating} —Ä–µ–π—Ç–∏–Ω–≥–∞
            `;
            logContainer.appendChild(rewardsEl);
        }


        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            const errorEl = document.getElementById('error');
            errorEl.style.display = 'block';
            errorEl.textContent = '‚ùå ' + message;
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        loadBattle();


        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
        window.onerror = function(msg, url, line) {
            console.error('–û—à–∏–±–∫–∞:', msg, url, line);
            addLog(`‚ùå –û—à–∏–±–∫–∞: ${msg}`);
            return false;
        };

    </script>
</body>
</html>




main.py:





# main.py
import os
import logging
from datetime import datetime
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from dotenv import load_dotenv

from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Update
from aiogram.client.default import DefaultBotProperties

from database.base import engine, AsyncSessionLocal
from bot.handlers.expedition import router as expedition_router
from bot.main_handlers import router as main_router
from bot.handlers.arena import router as arena_router

from bot.keyboards import set_bot_commands
from sqlalchemy import text

from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from pathlib import Path

from services.redis_client import battle_storage
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from database.models import User
from game.arena_battle_system import ArenaBattle, BattleCard


# –ú–æ–¥–µ–ª–∏ –¥–ª—è API
class TurnRequest(BaseModel):
    battle_id: str
    selected_card_id: Optional[int] = None  # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –≤—ã–±–æ—Ä –∫–∞—Ä—Ç—ã –¥–ª—è –∞—Ç–∞–∫–∏


class BattleResponse(BaseModel):
    success: bool
    player_cards: Optional[List[Dict]] = None
    enemy_cards: Optional[List[Dict]] = None
    turn: Optional[int] = None
    log: Optional[List[str]] = None
    winner: Optional[str] = None
    rewards: Optional[Dict[str, int]] = None
    error: Optional[str] = None


load_dotenv()

# ===== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–Ø =====
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# ===== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =====
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_WEBHOOK_SECRET = os.getenv("TELEGRAM_WEBHOOK_SECRET")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

# ===== TELEGRAM –ë–û–¢ =====
bot = Bot(token=TELEGRAM_BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
dp.include_router(expedition_router)
dp.include_router(main_router)
dp.include_router(arena_router)


# ===== FASTAPI LIFESPAN =====
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ Kami Deck...")
    await set_bot_commands(bot)

    if os.getenv("REDIS_URL"):  # —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ Redis –Ω–∞—Å—Ç—Ä–æ–µ–Ω
        await battle_storage.connect()

    yield
    # Shutdown
    await bot.session.close()
    await engine.dispose()
    logger.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")


# ===== FASTAPI –ü–†–ò–õ–û–ñ–ï–ù–ò–ï =====
app = FastAPI(
    title="Kami Deck Bot",
    description="–ò–≥—Ä–æ–≤–æ–π –∫–∞—Ä—Ç–æ—á–Ω—ã–π –±–æ—Ç –¥–ª—è Telegram",
    version="2.0.0",
    lifespan=lifespan,
)

# –ú–æ–Ω—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
app.mount("/static", StaticFiles(directory="static"), name="static")

# ===== –≠–ù–î–ü–û–ò–ù–¢–´ =====


# –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –∞—Ä–µ–Ω—ã (—Ñ–∞–π–ª —Ç–µ–ø–µ—Ä—å –≤ –∫–æ—Ä–Ω–µ)
@app.get("/arena.html", response_class=HTMLResponse)
async def get_arena():
    """–û—Å–Ω–æ–≤–Ω–æ–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è WebApp"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–∞ –≤ –∫–æ—Ä–Ω–µ
        arena_path = Path("arena.html")
        if arena_path.exists():
            content = arena_path.read_text(encoding="utf-8")
            return HTMLResponse(content=content)

        # –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–æ—Ä–Ω–µ, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤ static
        static_path = Path("static/arena.html")
        if static_path.exists():
            content = static_path.read_text(encoding="utf-8")
            return HTMLResponse(content=content)

        # –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω
        return HTMLResponse(
            content="<h1>Arena file not found</h1><p>Checked: arena.html, static/arena.html</p>",
            status_code=404,
        )
    except Exception as e:
        logger.exception(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ arena.html: {e}")
        return HTMLResponse(content=f"<h1>Error: {e}</h1>", status_code=500)


# –†–µ–¥–∏—Ä–µ–∫—Ç –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
@app.get("/static/arena.html")
async def static_arena_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å /static –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —ç–Ω–¥–ø–æ–∏–Ω—Ç"""
    return HTMLResponse(content="""
    <html>
        <head>
            <meta http-equiv="refresh" content="0;url=/arena.html">
        </head>
        <body>
            <p>Redirecting to /arena.html...</p>
        </body>
    </html>
    """)


# –¢–µ—Å—Ç–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å
@app.get("/test-arena")
async def test_arena():
    return HTMLResponse("""
    <html>
        <body>
            <h1>–¢–µ—Å—Ç–æ–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞</h1>
            <p>–ï—Å–ª–∏ –≤—ã —ç—Ç–æ –≤–∏–¥–∏—Ç–µ - —Å–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç</p>
            <p><a href="/arena.html">–ü–µ—Ä–µ–π—Ç–∏ –∫ –∞—Ä–µ–Ω–µ</a></p>
        </body>
    </html>
    """)


# –û—Å–Ω–æ–≤–Ω–æ–π —ç–Ω–¥–ø–æ–∏–Ω—Ç
@app.get("/")
async def root():
    return {
        "status": "online",
        "service": "Anime Cards Game Bot",
        "version": "2.0.0",
        "docs": "/docs",
    }


@app.post("/webhook")
async def telegram_webhook(request: Request):
    secret_token = request.headers.get("X-Telegram-Bot-Api-Secret-Token")
    if secret_token != TELEGRAM_WEBHOOK_SECRET:
        logger.warning(f"–ù–µ–≤–µ—Ä–Ω—ã–π —Å–µ–∫—Ä–µ—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω: {secret_token}")
        raise HTTPException(status_code=403, detail="Forbidden")

    try:
        update_data = await request.json()
        update = Update(**update_data)
        await dp.feed_update(bot=bot, update=update)
        return {"status": "ok"}
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–µ–±—Ö—É–∫–∞: {e}")
        return JSONResponse(
            status_code=500, content={"status": "error", "error": str(e)}
        )


@app.get("/webhook-info")
async def get_webhook_info():
    webhook_info = await bot.get_webhook_info()
    return {
        "url": webhook_info.url,
        "pending_update_count": webhook_info.pending_update_count,
        "last_error_message": webhook_info.last_error_message,
    }


@app.get("/health")
async def health_check():
    try:
        async with AsyncSessionLocal() as session:
            await session.execute(text("SELECT 1"))
        return {
            "status": "healthy",
            "database": "connected",
            "timestamp": datetime.now().isoformat(),
        }
    except Exception as e:
        return {"status": "unhealthy", "database": "disconnected", "error": str(e)}


# API —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
@app.get("/api/battle/{battle_id}")
async def get_battle(battle_id: str):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–∏—Ç–≤—ã"""
    try:
        logger.info(f"Getting battle {battle_id} from Redis")
        battle_data = await battle_storage.get_battle(battle_id)

        if not battle_data:
            logger.error(f"Battle {battle_id} not found in Redis")
            return {"success": False, "error": "Battle not found"}

        logger.info(
            f"Battle {battle_id} found: {len(battle_data.get('player_cards', []))} player cards"
        )

        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–æ–ª—è is_alive –≤ –∫–∞–∂–¥–æ–π –∫–∞—Ä—Ç–µ
        for card in battle_data.get("player_cards", []):
            if "is_alive" not in card:
                card["is_alive"] = card.get("health", 0) > 0

        for card in battle_data.get("enemy_cards", []):
            if "is_alive" not in card:
                card["is_alive"] = card.get("health", 0) > 0

        return {
            "success": True,
            "player_cards": battle_data.get("player_cards", []),
            "enemy_cards": battle_data.get("enemy_cards", []),
            "turn": battle_data.get("turn", 0),
        }
    except Exception as e:
        logger.exception(f"Error in get_battle: {e}")
        return {"success": False, "error": str(e)}


@app.post("/api/battle/turn")
async def battle_turn(request: TurnRequest):
    """–í—ã–ø–æ–ª–Ω–∏—Ç—å —Ö–æ–¥ –≤ –±–∏—Ç–≤–µ"""
    try:
        battle_data = await battle_storage.get_battle(request.battle_id)
        if not battle_data:
            return {"success": False, "error": "Battle not found"}

        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞—Ä—Ç—ã –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        player_cards_dict = {}
        enemy_cards_dict = {}

        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç—ã –∫–∞—Ä—Ç –¥–ª—è –±–æ—è
        for card_data in battle_data.get("player_cards", []):
            card = BattleCard(
                id=card_data["id"],
                user_card_id=card_data["user_card_id"],
                name=card_data["name"],
                rarity=card_data.get("rarity", "E"),
                anime=card_data.get("anime", ""),
                power=card_data["power"],
                health=card_data["health"],
                max_health=card_data["max_health"],
                attack=card_data["attack"],
                defense=card_data["defense"],
                level=card_data.get("level", 1),
                image_url=card_data.get("image_url", ""),
                position=card_data.get("position", 0),
            )
            player_cards_dict[card.id] = card

        for card_data in battle_data.get("enemy_cards", []):
            card = BattleCard(
                id=card_data["id"],
                user_card_id=card_data.get("user_card_id", -card_data["id"]),
                name=card_data["name"],
                rarity=card_data.get("rarity", "E"),
                anime=card_data.get("anime", ""),
                power=card_data["power"],
                health=card_data["health"],
                max_health=card_data["max_health"],
                attack=card_data["attack"],
                defense=card_data["defense"],
                level=card_data.get("level", 1),
                image_url=card_data.get("image_url", ""),
                position=card_data.get("position", 0),
            )
            enemy_cards_dict[card.id] = card

        # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –±–∏—Ç–≤—ã
        battle = ArenaBattle(
            list(player_cards_dict.values()), list(enemy_cards_dict.values())
        )

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ö–æ–¥
        battle.turn = battle_data.get("turn", 0)

        # –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
        actions = battle.next_turn()

        # –õ–æ–≥–∏ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
        battle_log = []
        for action in actions:
            if action.damage > 0:
                crit_text = " –ö–†–ò–¢!" if action.is_critical else ""
                battle_log.append(
                    f"‚öîÔ∏è {action.attacker_name} –∞—Ç–∞–∫—É–µ—Ç {action.defender_name} "
                    f"–Ω–∞ {action.damage}{crit_text}"
                )
                if action.is_dead:
                    battle_log.append(f"üíÄ {action.defender_name} –ø–æ–≤–µ—Ä–∂–µ–Ω!")

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        battle_data["player_cards"] = [
            card.to_dict() for card in player_cards_dict.values()
        ]
        battle_data["enemy_cards"] = [
            card.to_dict() for card in enemy_cards_dict.values()
        ]
        battle_data["turn"] = battle.turn
        battle_data["winner"] = battle.winner

        await battle_storage.save_battle(request.battle_id, battle_data)

        # –°–æ–±–∏—Ä–∞–µ–º actions –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
        actions_data = []
        for action in actions:
            actions_data.append(
                {
                    "attacker_id": action.attacker_id,
                    "attacker_name": action.attacker_name,
                    "defender_id": action.defender_id,
                    "defender_name": action.defender_name,
                    "damage": action.damage,
                    "is_critical": action.is_critical,
                    "is_dead": action.is_dead,
                }
            )

        return {
            "success": True,
            "turn": battle.turn,
            "player_cards": battle_data["player_cards"],
            "enemy_cards": battle_data["enemy_cards"],
            "log": battle_log,
            "actions": actions_data,
            "winner": battle.winner,
            "rewards": (
                {"coins": 50, "dust": 50, "rating": 20}
                if battle.winner == "player"
                else (
                    {"coins": 25, "dust": 25, "rating": -15}
                    if battle.winner == "enemy"
                    else None
                )
            ),
        }

    except Exception as e:
        logger.exception(f"Error in battle_turn: {e}")
        return {"success": False, "error": str(e)}


async def create_test_battle(battle_id: str):
    """–°–æ–∑–¥–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é –±–∏—Ç–≤—É –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏"""
    player_cards = [
        {
            "id": 1,
            "name": "–ö–∞—Ä—Ç–∞ 1",
            "power": 100,
            "health": 500,
            "max_health": 500,
            "attack": 50,
            "defense": 30,
            "level": 1,
            "rarity": "A",
        },
        {
            "id": 2,
            "name": "–ö–∞—Ä—Ç–∞ 2",
            "power": 150,
            "health": 450,
            "max_health": 450,
            "attack": 70,
            "defense": 40,
            "level": 2,
            "rarity": "S",
        },
        {
            "id": 3,
            "name": "–ö–∞—Ä—Ç–∞ 3",
            "power": 120,
            "health": 550,
            "max_health": 550,
            "attack": 60,
            "defense": 35,
            "level": 1,
            "rarity": "B",
        },
    ]

    enemy_cards = [
        {
            "id": -1,
            "name": "–í—Ä–∞–≥ 1",
            "power": 80,
            "health": 400,
            "max_health": 400,
            "attack": 40,
            "defense": 20,
            "level": 1,
            "rarity": "B",
        },
        {
            "id": -2,
            "name": "–í—Ä–∞–≥ 2",
            "power": 90,
            "health": 380,
            "max_health": 380,
            "attack": 45,
            "defense": 25,
            "level": 1,
            "rarity": "B",
        },
        {
            "id": -3,
            "name": "–í—Ä–∞–≥ 3",
            "power": 70,
            "health": 420,
            "max_health": 420,
            "attack": 35,
            "defense": 30,
            "level": 1,
            "rarity": "C",
        },
    ]

    battle_data = {
        "player_cards": player_cards,
        "enemy_cards": enemy_cards,
        "turn": 0,
        "created_at": datetime.now().isoformat(),
    }

    await battle_storage.save_battle(battle_id, battle_data)

    return {
        "success": True,
        "player_cards": player_cards,
        "enemy_cards": enemy_cards,
        "turn": 0,
    }


@app.post("/api/battle/result")
async def battle_result(request: Request):
    """–≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –±–æ—è —Å initData –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º initData –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞
        init_data = request.headers.get("X-Init-Data")
        logger.info(f"üî• Battle result received with init_data: {init_data}")

        if not init_data:
            return {"success": False, "error": "Missing init_data"}

        # –î–µ–∫–æ–¥–∏—Ä—É–µ–º init_data
        import base64
        import json

        try:
            # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∏–∑ base64
            decoded_json = base64.b64decode(init_data).decode()
            init_data_obj = json.loads(decoded_json)
            logger.info(f"Decoded init_data: {init_data_obj}")

            user_id = init_data_obj.get("user_id")
            battle_id_from_init = init_data_obj.get("battle_id")

            if not user_id:
                return {"success": False, "error": "Invalid init_data: no user_id"}

        except Exception as e:
            logger.error(f"Failed to decode init_data: {e}")
            return {"success": False, "error": f"Invalid init_data: {e}"}

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–µ–ª–∞ –∑–∞–ø—Ä–æ—Å–∞
        data = await request.json()
        logger.info(f"Battle result data: {data}")

        action = data.get("action")
        battle_id = data.get("battle_id")
        result = data.get("result")
        rewards = data.get("rewards", {})

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ battle_id —Å–æ–≤–ø–∞–¥–∞–µ—Ç
        if battle_id != battle_id_from_init:
            logger.error(f"Battle ID mismatch: {battle_id} vs {battle_id_from_init}")
            return {"success": False, "error": "Battle ID mismatch"}

        if action != "battle_result":
            return {"success": False, "error": "Invalid action"}

        # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ telegram_id
        async with AsyncSessionLocal() as session:
            from database.crud import get_user_or_create

            # –í–∞–∂–Ω–æ: user_id –∏–∑ init_data - —ç—Ç–æ telegram_id
            user = await get_user_or_create(session, int(user_id))

            if not user:
                return {"success": False, "error": "User not found"}

            logger.info(f"Updating user {user.id} with battle result: {result}")

            # –ù–∞—á–∏—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—ã
            if result == "win":
                rating_change = rewards.get("rating", 20)
                coins_reward = rewards.get("coins", 50)
                dust_reward = rewards.get("dust", 50)

                user.arena_wins += 1
                user.arena_rating += rating_change
                user.coins += coins_reward
                user.dust += dust_reward

                logger.info(f"üèÜ Win: +{coins_reward}üí∞ +{dust_reward}‚ú® +{rating_change}‚≠ê")

            elif result == "lose":
                rating_change = rewards.get("rating", -15)
                coins_reward = rewards.get("coins", 25)
                dust_reward = rewards.get("dust", 25)

                user.arena_losses += 1
                user.arena_rating = max(0, user.arena_rating + rating_change)
                user.coins += coins_reward
                user.dust += dust_reward

                logger.info(f"üíî Lose: +{coins_reward}üí∞ +{dust_reward}‚ú® {rating_change}‚≠ê")

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
            await session.commit()

            # –£–¥–∞–ª—è–µ–º –±–∏—Ç–≤—É –∏–∑ Redis
            if battle_id:
                await battle_storage.delete_battle(battle_id)

            return {
                "success": True,
                "user": {
                    "id": user.id,
                    "coins": user.coins,
                    "dust": user.dust,
                    "arena_rating": user.arena_rating,
                    "arena_wins": user.arena_wins,
                    "arena_losses": user.arena_losses
                }
            }

    except Exception as e:
        logger.exception(f"Error in battle_result: {e}")
        return {"success": False, "error": str(e)}


@app.post("/api/battle/verify")
async def verify_battle_access(request: Request):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –±–∏—Ç–≤–µ —á–µ—Ä–µ–∑ init_data"""
    try:
        data = await request.json()
        battle_id = data.get("battle_id")
        init_data = data.get("init_data")

        if not battle_id or not init_data:
            return {"success": False, "error": "Missing data"}

        # –î–µ–∫–æ–¥–∏—Ä—É–µ–º init_data
        import base64
        import json

        try:
            decoded = json.loads(base64.b64decode(init_data).decode())
            user_id = decoded.get("user_id")
            timestamp = decoded.get("timestamp")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –±–∏—Ç–≤–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —ç—Ç–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            battle_data = await battle_storage.get_battle(battle_id)
            if not battle_data:
                return {"success": False, "error": "Battle not found"}

            if str(battle_data.get("user_id")) != str(user_id):
                return {"success": False, "error": "Access denied"}

            return {
                "success": True,
                "user_id": user_id,
                "battle_id": battle_id
            }

        except Exception as e:
            return {"success": False, "error": f"Invalid init_data: {e}"}

    except Exception as e:
        logger.exception(f"Error in verify: {e}")
        return {"success": False, "error": str(e)}


# —Ç–µ—Å—Ç–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Redis
@app.get("/debug/redis")
async def debug_redis():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ Redis"""
    try:
        import redis.asyncio as redis

        r = redis.from_url(os.getenv("REDIS_URL", "redis://localhost:6379"))

        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–ª—é—á–∏
        keys = await r.keys("*")

        # –ü–æ–ª—É—á–∞–µ–º –æ–¥–∏–Ω –∫–ª—é—á –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
        sample = None
        if keys:
            sample = await r.get(keys[0])

        return {
            "status": "ok",
            "keys_count": len(keys),
            "keys": [k.decode() if isinstance(k, bytes) else k for k in keys[:10]],
            "sample": (
                sample.decode() if sample and isinstance(sample, bytes) else str(sample)
            ),
        }
    except Exception as e:
        return {"status": "error", "error": str(e)}


@app.get("/debug/battle/{battle_id}")
async def debug_battle(battle_id: str):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –±–∏—Ç–≤—ã"""
    try:
        battle_data = await battle_storage.get_battle(battle_id)
        if not battle_data:
            return {"status": "not_found", "battle_id": battle_id}

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö
        return {
            "status": "found",
            "battle_id": battle_id,
            "has_player_cards": len(battle_data.get("player_cards", [])) > 0,
            "player_cards_count": len(battle_data.get("player_cards", [])),
            "has_enemy_cards": len(battle_data.get("enemy_cards", [])) > 0,
            "enemy_cards_count": len(battle_data.get("enemy_cards", [])),
            "turn": battle_data.get("turn", 0),
            "created_at": battle_data.get("created_at"),
        }
    except Exception as e:
        return {"status": "error", "error": str(e)}


# —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
@app.get("/debug/create-test-battle")
async def create_test_battle_endpoint():
    """–°–æ–∑–¥–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é –±–∏—Ç–≤—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏"""
    import uuid

    battle_id = str(uuid.uuid4())

    player_cards = [
        {
            "id": 1,
            "user_card_id": 1,
            "name": "–¢–µ—Å—Ç–æ–≤–∞—è –∫–∞—Ä—Ç–∞ 1",
            "rarity": "A",
            "power": 100,
            "health": 500,
            "max_health": 500,
            "attack": 50,
            "defense": 30,
            "level": 1,
            "image_url": "",
            "position": 0,
            "is_alive": True,
        },
        {
            "id": 2,
            "user_card_id": 2,
            "name": "–¢–µ—Å—Ç–æ–≤–∞—è –∫–∞—Ä—Ç–∞ 2",
            "rarity": "S",
            "power": 150,
            "health": 450,
            "max_health": 450,
            "attack": 70,
            "defense": 40,
            "level": 2,
            "image_url": "",
            "position": 1,
            "is_alive": True,
        },
    ]

    enemy_cards = [
        {
            "id": -1,
            "user_card_id": -1,
            "name": "–¢–µ—Å—Ç–æ–≤—ã–π –≤—Ä–∞–≥ 1",
            "rarity": "B",
            "power": 80,
            "health": 400,
            "max_health": 400,
            "attack": 40,
            "defense": 20,
            "level": 1,
            "image_url": "",
            "position": 0,
            "is_alive": True,
        }
    ]

    battle_data = {
        "user_id": 12345,
        "opponent_id": None,
        "player_cards": player_cards,
        "enemy_cards": enemy_cards,
        "turn": 0,
        "winner": None,
        "created_at": datetime.now().isoformat(),
    }

    await battle_storage.save_battle(battle_id, battle_data)

    return {
        "success": True,
        "battle_id": battle_id,
        "url": f"/api/battle/{battle_id}",
        "debug_url": f"/debug/battle/{battle_id}",
    }


@app.get("/test-battle-access")
async def test_battle_access():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø –∫ API –±–∏—Ç–≤—ã"""
    import uuid

    battle_id = str(uuid.uuid4())

    # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é –±–∏—Ç–≤—É
    await create_test_battle(battle_id)

    # –ü—Ä–æ–±—É–µ–º –µ–µ –ø–æ–ª—É—á–∏—Ç—å
    battle_data = await battle_storage.get_battle(battle_id)

    return {
        "created_battle_id": battle_id,
        "battle_exists": battle_data is not None,
        "api_url": f"/api/battle/{battle_id}",
        "test_url": f"/debug/battle/{battle_id}",
    }


@app.get("/test-webapp")
async def test_webapp():
    return HTMLResponse("""
    <html>
    <body>
        <h1>–¢–µ—Å—Ç WebApp</h1>
        <script>
            function sendTestData() {
                const tg = window.Telegram?.WebApp;
                if (tg) {
                    tg.sendData(JSON.stringify({
                        action: 'battle_result',
                        result: 'win',
                        rewards: {coins: 50, dust: 50, rating: 20}
                    }));
                    alert('–î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã!');
                } else {
                    alert('WebApp –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
                }
            }
        </script>
        <button onclick="sendTestData()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ</button>
    </body>
    </html>
    """)


@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.exception(f"Global exception: {exc}")
    return JSONResponse(
        status_code=500, content={"status": "error", "detail": "Internal server error"}
    )










redis_client.py:



import redis.asyncio as redis
import json
import os
import logging
from typing import Optional, Dict


logger = logging.getLogger(__name__)

REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")

class BattleStorage:
    def __init__(self):
        self.redis = None

    async def connect(self):
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis"""
        try:
            self.redis = redis.from_url(REDIS_URL, decode_responses=True)
            await self.redis.ping()
            logger.info("‚úÖ Redis connected successfully")
        except Exception as e:
            logger.error(f"‚ùå Redis connection failed: {e}")
            raise

    async def save_battle(self, battle_id: str, battle_data: Dict, ttl: int = 300):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—è –Ω–∞ 5 –º–∏–Ω—É—Ç"""
        if not self.redis:
            await self.connect()
        key = f"battle:{battle_id}"
        await self.redis.setex(
            key,
            ttl,
            json.dumps(battle_data, default=str)
        )
        logger.info(f"‚úÖ Battle {battle_id} saved to Redis")

    async def get_battle(self, battle_id: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—è"""
        if not self.redis:
            await self.connect()
        key = f"battle:{battle_id}"
        data = await self.redis.get(key)
        if data:
            logger.info(f"‚úÖ Battle {battle_id} found in Redis")
            return json.loads(data)
        logger.warning(f"‚ùå Battle {battle_id} not found in Redis")
        return None

    async def delete_battle(self, battle_id: str):
        """–£–¥–∞–ª—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—è"""
        if not self.redis:
            await self.connect()
        key = f"battle:{battle_id}"
        await self.redis.delete(key)
        logger.info(f"‚úÖ Battle {battle_id} deleted from Redis")


battle_storage = BattleStorage()


game/arena_battle_system.py:
# game/arena_battle_system.py
import random
import math
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass, asdict

@dataclass
class BattleCard:
    """–ö–∞—Ä—Ç–∞ –≤ –±–æ—é"""
    id: int
    user_card_id: int
    name: str
    rarity: str
    anime: str
    power: int
    health: int
    max_health: int
    attack: int
    defense: int
    level: int
    image_url: Optional[str] = None
    position: int = 0

    def take_damage(self, damage: int) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —É—Ä–æ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–π —É—Ä–æ–Ω"""
        actual_damage = min(damage, self.health)
        self.health -= actual_damage
        return actual_damage

    def is_alive(self) -> bool:
        return self.health > 0

    def to_dict(self) -> dict:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è API"""
        return {
            "id": self.id,
            "user_card_id": self.user_card_id,
            "name": self.name,
            "rarity": self.rarity,
            "power": self.power,
            "health": max(0, self.health),
            "max_health": self.max_health,
            "attack": self.attack,
            "defense": self.defense,
            "level": self.level,
            "image_url": self.image_url,
            "position": self.position,
            "is_alive": self.is_alive()
        }

@dataclass
class BattleAction:
    """–î–µ–π—Å—Ç–≤–∏–µ –≤ –±–æ—é"""
    attacker_id: int
    attacker_name: str
    defender_id: int
    defender_name: str
    damage: int
    is_critical: bool = False
    is_dodged: bool = False
    is_dead: bool = False

class ArenaBattle:
    """–°–∏—Å—Ç–µ–º–∞ –±–æ—è –Ω–∞ –∞—Ä–µ–Ω–µ"""

    def __init__(self, player_cards: List[BattleCard], enemy_cards: List[BattleCard]):
        self.player_cards = {c.id: c for c in player_cards}
        self.enemy_cards = {c.id: c for c in enemy_cards}
        self.turn = 0
        self.actions: List[BattleAction] = []
        self.winner: Optional[str] = None  # 'player', 'enemy', –∏–ª–∏ None

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–Ω–µ—Ä–≥–∏–∏ –≤ –∫–æ–ª–æ–¥–µ
        self.player_synergies = self._check_synergies(list(self.player_cards.values()))
        self.enemy_synergies = self._check_synergies(list(self.enemy_cards.values()))

    def _check_synergies(self, cards: List[BattleCard]) -> Dict[str, int]:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–∏–Ω–µ—Ä–≥–∏–∏ –≤ –∫–æ–ª–æ–¥–µ (–∫–∞—Ä—Ç—ã –∏–∑ –æ–¥–Ω–æ–≥–æ –∞–Ω–∏–º–µ)"""
        anime_counts = {}
        for card in cards:
            if card.anime:
                anime_counts[card.anime] = anime_counts.get(card.anime, 0) + 1

        synergies = {}
        for anime, count in anime_counts.items():
            if count >= 3:
                synergies[anime] = 15  # +15% –∫ —Å—Ç–∞—Ç–∞–º
            elif count >= 2:
                synergies[anime] = 10  # +10% –∫ —Å—Ç–∞—Ç–∞–º

        return synergies

    def _calculate_damage(self, attacker: BattleCard, defender: BattleCard) -> Tuple[int, bool]:
        """–†–∞—Å—á–µ—Ç —É—Ä–æ–Ω–∞ —Å —É—á–µ—Ç–æ–º –∫—Ä–∏—Ç–æ–≤"""
        # –ë–∞–∑–æ–≤–∞—è –∞—Ç–∞–∫–∞ –º–∏–Ω—É—Å –∑–∞—â–∏—Ç–∞
        base_damage = max(25, attacker.attack - defender.defense // 3)

        # –®–∞–Ω—Å –∫—Ä–∏—Ç–∞ (10%)
        is_critical = random.random() < 0.1
        if is_critical:
            base_damage = int(base_damage * 1.5)

        # –†–∞–Ω–¥–æ–º–Ω—ã–π —Ä–∞–∑–±—Ä–æ—Å ¬±20%
        damage = int(base_damage * random.uniform(0.8, 1.2))

        return max(1, damage), is_critical

    def _get_alive_cards(self, is_player: bool) -> List[BattleCard]:
        """–ü–æ–ª—É—á–∏—Ç—å –∂–∏–≤—ã–µ –∫–∞—Ä—Ç—ã —Å—Ç–æ—Ä–æ–Ω—ã"""
        cards_dict = self.player_cards if is_player else self.enemy_cards
        return [c for c in cards_dict.values() if c.is_alive()]

    def next_turn(self) -> List[BattleAction]:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥"""
        if self.winner:
            return []

        self.turn += 1
        turn_actions = []

        # –ü–æ–ª—É—á–∞–µ–º –∂–∏–≤—ã–µ –∫–∞—Ä—Ç—ã
        alive_players = self._get_alive_cards(True)
        alive_enemies = self._get_alive_cards(False)

        # –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –æ—Å—Ç–∞–ª—Å—è –±–µ–∑ –∫–∞—Ä—Ç - –±–∏—Ç–≤–∞ –æ–∫–æ–Ω—á–µ–Ω–∞
        if not alive_players:
            self.winner = 'enemy'
            return []
        if not alive_enemies:
            self.winner = 'player'
            return []

        # –ö–æ–ø–∏—Ä—É–µ–º —Å–ø–∏—Å–∫–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
        players_to_attack = alive_players.copy()
        enemies_to_attack = alive_enemies.copy()

        # –í—Å–µ –∂–∏–≤—ã–µ –∫–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞ –∞—Ç–∞–∫—É—é—Ç —Å–ª—É—á–∞–π–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤
        for player in players_to_attack:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å –∂–∏–≤—ã–µ –≤—Ä–∞–≥–∏
            current_alive_enemies = [c for c in enemies_to_attack if c.is_alive()]
            if not current_alive_enemies:
                break

            target = random.choice(current_alive_enemies)
            damage, is_critical = self._calculate_damage(player, target)

            actual_damage = target.take_damage(damage)

            action = BattleAction(
                attacker_id=player.id,
                attacker_name=player.name,
                defender_id=target.id,
                defender_name=target.name,
                damage=actual_damage,
                is_critical=is_critical,
                is_dead=not target.is_alive()
            )
            turn_actions.append(action)

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∂–∏–≤—ã—Ö –≤—Ä–∞–≥–æ–≤ –ø–æ—Å–ª–µ –∞—Ç–∞–∫ –∏–≥—Ä–æ–∫–∞
        alive_enemies = self._get_alive_cards(False)
        enemies_to_attack = alive_enemies.copy()

        # –í—Å–µ –∂–∏–≤—ã–µ –∫–∞—Ä—Ç—ã –≤—Ä–∞–≥–∞ –∞—Ç–∞–∫—É—é—Ç —Å–ª—É—á–∞–π–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
        for enemy in enemies_to_attack:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å –∂–∏–≤—ã–µ –∏–≥—Ä–æ–∫–∏
            current_alive_players = [c for c in players_to_attack if c.is_alive()]
            if not current_alive_players:
                break

            target = random.choice(current_alive_players)
            damage, is_critical = self._calculate_damage(enemy, target)

            actual_damage = target.take_damage(damage)

            action = BattleAction(
                attacker_id=enemy.id,
                attacker_name=enemy.name,
                defender_id=target.id,
                defender_name=target.name,
                damage=actual_damage,
                is_critical=is_critical,
                is_dead=not target.is_alive()
            )
            turn_actions.append(action)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –ø–æ—Å–ª–µ —Ö–æ–¥–∞
        alive_players = self._get_alive_cards(True)
        alive_enemies = self._get_alive_cards(False)

        if not alive_players:
            self.winner = 'enemy'
        elif not alive_enemies:
            self.winner = 'player'

        self.actions.extend(turn_actions)
        return turn_actions

    def get_battle_state(self) -> dict:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—è"""
        return {
            "turn": self.turn,
            "winner": self.winner,
            "player_cards": [c.to_dict() for c in self.player_cards.values()],
            "enemy_cards": [c.to_dict() for c in self.enemy_cards.values()],
            "player_synergies": self.player_synergies,
            "enemy_synergies": self.enemy_synergies,
            "actions": [asdict(a) for a in self.actions[-10:]]  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –¥–µ–π—Å—Ç–≤–∏–π
        }

    def auto_battle(self) -> List[BattleAction]:
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –±–æ–π –¥–æ –∫–æ–Ω—Ü–∞"""
        all_actions = []
        while not self.winner:
            turn_actions = self.next_turn()
            all_actions.extend(turn_actions)
        return all_actions

